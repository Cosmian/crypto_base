use crate::{
    asymmetric::ristretto::{X25519PrivateKey, X25519PublicKey},
    hybrid_crypto::Kem,
    kdf::hkdf_256,
    CryptoBaseError, KeyTrait,
};
use rand_core::{CryptoRng, RngCore};

/// Structure containing the scheme parameter `Gamma`.
/// It is composed of `L` vectors of length `2K`, where `L` is th enumber of
/// users, and `K` the maximum number of traitors allowed so that the scheme
/// can trace them.
pub struct BonnehFranklin<const K: usize, const L: usize> {
    gamma: Vec<Vec<X25519PrivateKey>>,
}

impl<const K: usize, const L: usize> BonnehFranklin<K, L> {
    /// Generate a new Bonnneh-Franklin scheme.
    pub fn new<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        Self {
            gamma: (0..L)
                .map(|_| (0..2 * K).map(|_| X25519PrivateKey::new(rng)).collect())
                .collect(),
        }
    }
}

/// Public key of the Bonneh-Franklin scheme. It can be associated to several
/// private keys. It is composed by `<y, h_1,...,h_2K>`
#[derive(Clone, Debug, PartialEq)]
pub struct BonnehFranklinPublicKey<const K: usize> {
    /// `y = Prod(h_i * alpha_i)` where `alpha_i` are random elements
    y: X25519PublicKey,
    /// List of length `L` with: `h_i = g * r_i`, with `r_i` arandom element
    h: Vec<X25519PublicKey>,
}

impl<const K: usize> KeyTrait for BonnehFranklinPublicKey<K> {
    /// Length of the public key: there is `y` and `2K` `h_i` elements.
    const LENGTH: usize = X25519PublicKey::LENGTH * (2 * K + 1);

    /// Serialize the public key.
    fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::with_capacity(Self::LENGTH);
        bytes.append(&mut self.y.to_bytes());
        for h_i in self.h.iter() {
            bytes.append(&mut h_i.to_bytes());
        }
        bytes
    }

    /// Deserilize the public key.
    fn try_from_bytes(bytes: &[u8]) -> Result<Self, CryptoBaseError> {
        if bytes.len() != Self::LENGTH {
            return Err(CryptoBaseError::SizeError {
                given: bytes.len(),
                expected: Self::LENGTH,
            });
        }
        let mut index = X25519PublicKey::LENGTH;
        let y = X25519PublicKey::try_from_bytes(&bytes[..index])?;
        let mut h = Vec::with_capacity(2 * K);
        for _ in 0..2 * K {
            h.push(X25519PublicKey::try_from_bytes(
                &bytes[index..index + X25519PublicKey::LENGTH],
            )?);
            index += X25519PublicKey::LENGTH;
        }
        Ok(Self { y, h })
    }
}

/// Bonneh Franklin private key.
///
/// `L` different private keys can be associated to the same public key.
/// For the user `i`, the private key consiste in the `theta_i` such that:
/// `theta_i = sum(r_j * alpha_j) / sum(r_j * gamma_j)`, where `gamma_j` is
/// the `j` composant of the the `i`th vector of `Gamma`.
#[derive(Clone, Debug, PartialEq)]
pub struct BonnehFranklinPrivateKey {
    /// user ID
    uid: u32,
    /// `theta_i = sum(r_j * alpha_j) / sum(r_j * gamma_j)`, where `gamma_j` is
    /// the `j` composant of the the `i`th vector of `Gamma`.
    theta: X25519PrivateKey,
}

impl KeyTrait for BonnehFranklinPrivateKey {
    /// Private key length. This is just a `u32` and a `scalar`.
    const LENGTH: usize = 4 + X25519PrivateKey::LENGTH;

    /// Key serialization.
    fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::with_capacity(Self::LENGTH);
        bytes.extend_from_slice(&self.uid.to_be_bytes());
        bytes.append(&mut self.theta.to_bytes());
        bytes
    }

    /// Key deserialization.
    fn try_from_bytes(bytes: &[u8]) -> Result<Self, CryptoBaseError> {
        if bytes.len() != Self::LENGTH {
            return Err(CryptoBaseError::SizeError {
                given: bytes.len(),
                expected: Self::LENGTH,
            });
        }
        let mut uid = [0; 4];
        uid.copy_from_slice(&bytes[..4]);
        let uid = u32::from_be_bytes(uid);
        let theta = X25519PrivateKey::try_from_bytes(&bytes[4..])?;
        Ok(Self { theta, uid })
    }
}

impl<const K: usize, const L: usize> Kem for BonnehFranklin<K, L> {
    /// Public key
    type PublicKey = BonnehFranklinPublicKey<K>;

    /// Private key
    type PrivateKey = BonnehFranklinPrivateKey;

    /// Key generated by the setup: one public key and its `L` associated
    /// private keys.
    type Keys = (Vec<Self::PublicKey>, Vec<Self::PrivateKey>);

    /// Size of the encapsulation
    const ENCAPSULATION_SIZE: usize = X25519PublicKey::LENGTH;

    fn description() -> String {
        todo!()
    }

    /// Generate the public key along with its `L` associated private keys.
    ///
    /// - `rng` : random number generator
    fn key_gen<R: RngCore + CryptoRng>(&self, rng: &mut R) -> Result<Self::Keys, CryptoBaseError> {
        // generate the random elements `r_i` and `alpha_i`
        let r = (0..2 * K)
            .map(|_| X25519PrivateKey::new(rng))
            .collect::<Vec<X25519PrivateKey>>();
        let alpha = (0..2 * K)
            .map(|_| X25519PrivateKey::new(rng))
            .collect::<Vec<X25519PrivateKey>>();

        // compute public key
        let h = r
            .iter()
            .map(X25519PublicKey::from)
            .collect::<Vec<X25519PublicKey>>();
        let y = h
            .iter()
            .zip(alpha.iter())
            .map(|(h_i, alpha_i)| h_i * alpha_i)
            .sum();

        // compute private key
        let precomputed_sum = r
            .iter()
            .zip(alpha.iter())
            .map(|(r_j, alpha_j)| r_j * alpha_j)
            .sum::<X25519PrivateKey>();
        let private_keys = self
            .gamma
            .iter()
            .enumerate()
            .map(|(i, gamma_i)| {
                Ok(BonnehFranklinPrivateKey {
                    theta: &r
                        .iter()
                        .zip(gamma_i.iter())
                        .map(|(r_j, gamma_ij)| r_j * gamma_ij)
                        .sum::<X25519PrivateKey>()
                        .invert()?
                        * &precomputed_sum,
                    uid: i as u32,
                })
            })
            .collect::<Result<Vec<BonnehFranklinPrivateKey>, CryptoBaseError>>()?;

        Ok((vec![BonnehFranklinPublicKey { y, h }], private_keys))
    }

    /// Return the symmetric key and its encapsulation.
    ///
    /// - `rng`             : random number generator
    /// - `pk`              : public key
    /// - `sym_key_length`  : length of the symmetric key
    fn encaps<R: RngCore + CryptoRng>(
        &self,
        rng: &mut R,
        pk: &Self::PublicKey,
        sym_key_length: usize,
    ) -> Result<(Vec<u8>, Vec<u8>), CryptoBaseError> {
        let shared_secret = X25519PublicKey::new(rng);
        let a = X25519PrivateKey::new(rng);
        let mut encapsulation = pk.clone();
        encapsulation.y = encapsulation.y * &a + &shared_secret;
        for h_i in encapsulation.h.iter_mut() {
            *h_i *= &a;
        }
        Ok((
            hkdf_256(&shared_secret.to_bytes(), sym_key_length, &[])?,
            encapsulation.to_bytes(),
        ))
    }

    /// Decapsulate the symmetric key.
    ///
    /// - `sk`              : private key
    /// - `encapsulation`   : symmetric key encapsulation
    /// - `sym_key_length`  : length of the desired symmetric key
    fn decaps(
        &self,
        sk: &Self::PrivateKey,
        encapsulation: &[u8],
        sym_key_length: usize,
    ) -> Result<Vec<u8>, CryptoBaseError> {
        let encapsulation = BonnehFranklinPublicKey::<K>::try_from_bytes(encapsulation)?;
        let shared_secret: X25519PublicKey = encapsulation.y
            - encapsulation
                .h
                .iter()
                .zip(self.gamma[sk.uid as usize].iter())
                .map(|(h_j, gamma_j)| h_j * gamma_j)
                .sum::<X25519PublicKey>()
                * &sk.theta;
        hkdf_256(&shared_secret.to_bytes(), sym_key_length, &[])
    }
}

#[cfg(test)]
mod tests {

    use super::*;
    use crate::entropy::CsRng;

    #[test]
    fn test_bonneh_franklin_key_serialization() {
        let mut rng = CsRng::new();
        let kem = BonnehFranklin::<2, 10>::new(&mut rng);
        let key_pair = kem.key_gen(&mut rng).expect("KeyGen failed");
        let pk = key_pair.0[0].to_owned();
        let bytes = pk.to_bytes();
        let res = BonnehFranklinPublicKey::<2>::try_from_bytes(&bytes).unwrap();
        assert_eq!(pk, res);
        let sk = key_pair.1[0].to_owned();
        let bytes = sk.to_bytes();
        let res = BonnehFranklinPrivateKey::try_from_bytes(&bytes).unwrap();
        assert_eq!(sk, res);
    }

    #[test]
    fn test_kem_bonneh_franklin() {
        const SECRET_KEY_LENGTH: usize = 32;
        const K: usize = 2;
        const L: usize = 10;
        let mut rng = CsRng::new();
        let kem = BonnehFranklin::<K, L>::new(&mut rng);
        let key_pair = kem.key_gen(&mut rng).expect("KeyGen failed");
        let (secret_key, encapsulation) = kem
            .encaps(&mut rng, &key_pair.0[0], SECRET_KEY_LENGTH)
            .expect("Encaps failed");
        let res = kem
            .decaps(&key_pair.1[0], &encapsulation, SECRET_KEY_LENGTH)
            .expect("Decaps failed");
        if secret_key != res {
            panic!("Wrong decapsulation!");
        }
    }
}
